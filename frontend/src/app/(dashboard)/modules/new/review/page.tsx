"use client";

import { useEffect, useRef, useState } from "react";
import { useRouter } from "next/navigation";
import { X } from "lucide-react";

import { Button, IconButton } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { Dialog, DialogContent } from "@/components/ui/dialog";
import { useModuleDraftStore } from "@/lib/stores/module-draft-store";
import { useSourcePolling } from "@/lib/hooks/use-source-polling";
import {
  usePreviewModuleContent,
  useGenerateOverview,
  useGenerateLearningGoals,
  useCreateModule,
} from "@/lib/hooks/use-modules";
import { useBatchDeleteSources } from "@/lib/hooks/use-sources";
import { modulesApi } from "@/lib/api/modules";
import { useCoursesStore } from "@/lib/stores/courses-store";

import { ModuleInfoPanel } from "@/components/modules/review/ModuleInfoPanel";
import { LearningGoalsPanel } from "@/components/modules/review/LearningGoalsPanel";
import { FilesSidebar } from "@/components/modules/review/FilesSidebar";
import { DeleteDraftModal } from "@/components/modules/review/DeleteDraftModal";
import { SourceDetailContent } from "@/components/source/SourceDetailContent";
import { AddFilesDialog } from "@/components/modules/review/AddFilesDialog";

export default function ModuleReviewPage() {
  const router = useRouter();
  const {
    pendingSourceIds,
    name,
    overview,
    learningGoals,
    targetCourseId,
    hasGeneratedContent,
    setModuleField,
    setGeneratedContent,
    reset,
  } = useModuleDraftStore();

  const { assignModuleToCourse } = useCoursesStore();

  // Polling and mutations
  const {
    allComplete,
    progressPercentage,
    statuses: sourceStatuses,
  } = useSourcePolling(pendingSourceIds);
  const previewContent = usePreviewModuleContent();
  const generateOverview = useGenerateOverview();
  const generateLearningGoals = useGenerateLearningGoals();
  const createModule = useCreateModule();
  const batchDelete = useBatchDeleteSources();

  // Local state
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [showAddFilesDialog, setShowAddFilesDialog] = useState(false);
  const [isConfirming, setIsConfirming] = useState(false);
  const [selectedSourceId, setSelectedSourceId] = useState<string | null>(null);
  const hasAutoGenerated = useRef(false);

  // Track files added after initial upload to trigger regeneration
  const pendingNewFilesRef = useRef<Set<string>>(new Set());
  const previousSourceCountRef = useRef(pendingSourceIds.length);

  // Redirect if no pending sources (user navigated directly to this page)
  useEffect(() => {
    if (pendingSourceIds.length === 0) {
      router.replace("/courses");
    }
  }, [pendingSourceIds.length, router]);

  // Navigation guard - warn about unsaved changes
  useEffect(() => {
    const handleBeforeUnload = (e: BeforeUnloadEvent) => {
      if (pendingSourceIds.length > 0) {
        e.preventDefault();
        // Modern browsers show a generic message, but we set returnValue for compatibility
        e.returnValue =
          "You have unsaved changes. Are you sure you want to leave?";
        return e.returnValue;
      }
    };

    window.addEventListener("beforeunload", handleBeforeUnload);
    return () => {
      window.removeEventListener("beforeunload", handleBeforeUnload);
    };
  }, [pendingSourceIds.length]);

  // Auto-generate content when all sources complete
  useEffect(() => {
    if (
      allComplete &&
      !hasGeneratedContent &&
      !hasAutoGenerated.current &&
      !previewContent.isPending &&
      pendingSourceIds.length > 0
    ) {
      hasAutoGenerated.current = true;

      previewContent.mutate(
        { source_ids: pendingSourceIds, name: name || "" },
        {
          onSuccess: (data) => {
            setGeneratedContent(
              data.overview,
              data.learning_goals.map((g) => ({
                description: g.description,
                takeaways: g.takeaways || "",
                competencies: g.competencies || "",
                order: g.order,
              }))
            );
            // Use AI-generated name if user hasn't set one
            if (!name && data.name) {
              setModuleField("name", data.name);
            }
          },
        }
      );
    }
    // Note: previewContent.mutate is stable, we only need isPending for the condition
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    allComplete,
    hasGeneratedContent,
    pendingSourceIds.length,
    previewContent.isPending,
  ]);

  // Detect when new files are added and track them
  useEffect(() => {
    if (pendingSourceIds.length > previousSourceCountRef.current) {
      // New files were added - track the new ones
      const newFiles = pendingSourceIds.slice(previousSourceCountRef.current);
      newFiles.forEach((id) => pendingNewFilesRef.current.add(id));
    }
    previousSourceCountRef.current = pendingSourceIds.length;
  }, [pendingSourceIds.length, pendingSourceIds]);

  // Regenerate content when new files finish processing
  useEffect(() => {
    if (pendingNewFilesRef.current.size === 0) return;
    if (previewContent.isPending) return;

    // Check if all new files have completed
    const newFilesComplete = Array.from(pendingNewFilesRef.current).every(
      (id) =>
        sourceStatuses[id] === "completed" || sourceStatuses[id] === "failed"
    );

    if (newFilesComplete && allComplete) {
      // Clear the pending new files set
      pendingNewFilesRef.current.clear();

      // Regenerate content with all sources
      previewContent.mutate(
        { source_ids: pendingSourceIds, name: name || "" },
        {
          onSuccess: (data) => {
            if (data.name) {
              setModuleField("name", data.name);
            }
            setGeneratedContent(
              data.overview,
              data.learning_goals.map((g) => ({
                description: g.description,
                takeaways: g.takeaways || "",
                competencies: g.competencies || "",
                order: g.order,
              }))
            );
          },
        }
      );
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [allComplete, sourceStatuses, previewContent.isPending]);

  // Handle regenerate overview only
  const handleRegenerateOverview = () => {
    if (pendingSourceIds.length === 0) return;

    generateOverview.mutate(
      { source_ids: pendingSourceIds, name: name || "New Module" },
      {
        onSuccess: (data) => {
          setModuleField("overview", data.overview);
        },
      }
    );
  };

  // Handle regenerate learning goals only
  const handleRegenerateLearningGoals = () => {
    if (pendingSourceIds.length === 0) return;

    generateLearningGoals.mutate(
      { source_ids: pendingSourceIds, name: name || "New Module" },
      {
        onSuccess: (data) => {
          setGeneratedContent(
            overview,
            data.learning_goals.map((g) => ({
              description: g.description,
              takeaways: g.takeaways || "",
              competencies: g.competencies || "",
              order: g.order,
            }))
          );
        },
      }
    );
  };

  // Handle cancel/delete draft
  const handleDeleteDraft = async () => {
    try {
      // Delete all uploaded sources
      if (pendingSourceIds.length > 0) {
        await batchDelete.mutateAsync(pendingSourceIds);
      }
      // Reset store and navigate away
      reset();
      router.push("/courses");
    } catch (error) {
      console.error("Error deleting draft:", error);
    }
  };

  // Handle X button click
  const handleClose = () => {
    setShowDeleteModal(true);
  };

  // Handle confirm - create module and link sources
  const handleConfirm = async () => {
    if (!name.trim()) {
      // Name is required
      return;
    }

    setIsConfirming(true);
    try {
      // 1. Create the module (include course_id if created from a course page)
      const module = await createModule.mutateAsync({
        name: name.trim(),
        description: overview || undefined,
        course_id: targetCourseId || undefined,
      });

      // 2. Link sources to the module
      await Promise.allSettled(
        pendingSourceIds.map((sourceId) =>
          modulesApi.addSource(module.id, sourceId)
        )
      );

      // 3. Create learning goals if any
      for (const goal of learningGoals) {
        await modulesApi.createLearningGoal(module.id, {
          description: goal.description,
          takeaways: goal.takeaways || undefined,
          competencies: goal.competencies || undefined,
          order: goal.order,
        });
      }

      // 4. Update overview if set
      if (overview) {
        await modulesApi.update(module.id, { overview });
      }

      // 5. Assign to course if created from course page
      if (targetCourseId) {
        assignModuleToCourse(module.id, targetCourseId);
      }

      // 6. Reset store and navigate to the new module
      reset();

      // Navigate to the module or course page
      if (targetCourseId) {
        router.push(
          `/courses/${encodeURIComponent(
            targetCourseId
          )}/modules/${encodeURIComponent(module.id)}`
        );
      } else {
        router.push(`/modules/${encodeURIComponent(module.id)}`);
      }
    } catch (error: unknown) {
      const axiosErr = error as { response?: { data?: unknown } };
      console.error("Error creating module:", error);
      if (axiosErr?.response?.data) {
        console.error("Server response:", JSON.stringify(axiosErr.response.data));
      }
    } finally {
      setIsConfirming(false);
    }
  };

  // Handle adding more files
  const handleAddMore = () => {
    setShowAddFilesDialog(true);
  };

  // Handle source click (view source details)
  const handleSourceClick = (sourceId: string) => {
    setSelectedSourceId(sourceId);
  };

  const isGeneratingAll = previewContent.isPending;
  const isGeneratingOverview = generateOverview.isPending || isGeneratingAll;
  const isGeneratingGoals = generateLearningGoals.isPending || isGeneratingAll;
  const isGenerating = isGeneratingOverview || isGeneratingGoals;
  const canConfirm = name.trim().length > 0 && !isGenerating && !isConfirming;

  // Don't render if no sources (will redirect)
  if (pendingSourceIds.length === 0) {
    return null;
  }

  return (
    <div className="flex flex-col h-full bg-background">
      {/* Header */}
      <header className="flex-shrink-0 flex items-center justify-between px-6 py-4 border-b">
        <div className="flex items-center gap-4">
          <IconButton size="sm" onClick={handleClose} aria-label="Close">
            <X />
          </IconButton>
          <h1 className="font-heading text-[32px] font-medium tracking-[-0.02em] text-primary">
            Create Module {">"} Review and Edit
          </h1>
        </div>
      </header>

      {/* Content - 3 column layout */}
      <main className="flex-1 min-h-0 overflow-hidden p-6">
        <div className="flex gap-6 h-full">
          {/* Left column - Module info */}
          <ModuleInfoPanel
            isGenerating={isGeneratingOverview}
            onRegenerateOverview={handleRegenerateOverview}
          />

          {/* Center column - Learning goals */}
          <LearningGoalsPanel
            isGenerating={isGeneratingGoals}
            onRegenerateLearningGoals={handleRegenerateLearningGoals}
          />

          {/* Right column - Files sidebar */}
          <FilesSidebar
            sourceIds={pendingSourceIds}
            sourceStatuses={sourceStatuses}
            onAddMore={handleAddMore}
            onSourceClick={handleSourceClick}
          />
        </div>
      </main>

      {/* Footer with progress and confirm */}
      <footer className="flex-shrink-0 px-6 py-4 border-t bg-background">
        <div className="flex items-center gap-4">
          {/* Progress bar */}
          <div className="flex-1">
            <Progress
              value={allComplete ? 100 : progressPercentage}
              className="h-2"
            />
          </div>

          {/* Progress percentage */}
          <span className="font-sans text-[14px] font-normal text-teal-800 w-12 text-right">
            {allComplete ? 100 : progressPercentage}%
          </span>

          {/* Confirm button */}
          <Button
            variant="accent"
            onClick={handleConfirm}
            disabled={!canConfirm}
          >
            {isConfirming ? "Creating..." : "Confirm"}
          </Button>
        </div>
      </footer>

      {/* Delete draft confirmation modal */}
      <DeleteDraftModal
        open={showDeleteModal}
        onOpenChange={setShowDeleteModal}
        onConfirm={handleDeleteDraft}
        isDeleting={batchDelete.isPending}
      />

      {/* Source detail dialog */}
      <Dialog
        open={selectedSourceId !== null}
        onOpenChange={(open) => {
          if (!open) setSelectedSourceId(null);
        }}
      >
        <DialogContent className="max-w-4xl max-h-[85vh] overflow-y-auto">
          {selectedSourceId && (
            <SourceDetailContent
              sourceId={selectedSourceId}
              onClose={() => setSelectedSourceId(null)}
            />
          )}
        </DialogContent>
      </Dialog>

      {/* Add more files dialog */}
      <AddFilesDialog
        open={showAddFilesDialog}
        onOpenChange={setShowAddFilesDialog}
      />
    </div>
  );
}
